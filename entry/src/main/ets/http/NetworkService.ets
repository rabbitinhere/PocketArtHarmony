import { http } from '@kit.NetworkKit';

export class HttpHelper {
  private static instance: HttpHelper;
  private requestQueue: Array<() => void> = [];
  private isProcessing = false;
  private lastRequestTime = 0;
  private readonly MIN_REQUEST_INTERVAL = 20; // å¤§éƒ½ä¼šç½‘ç«™è¯´ï¼Œä¸èƒ½å¤§äº1ç§’80æ¬¡è¯·æ±‚ï¼Œæˆ‘è®¾ç½®æˆ1ç§’50æ¬¡ä»¥å†…ï¼ˆ20æ¯«ç§’ä¸€æ¬¡ï¼‰

  private constructor() {
  }

  static getInstance(): HttpHelper {
    if (!HttpHelper.instance) {
      HttpHelper.instance = new HttpHelper();
    }
    return HttpHelper.instance;
  }

  async request(url: string, options?: http.HttpRequestOptions): Promise<http.HttpResponse> {
    return new Promise((resolve, reject) => {
      this.addToQueue(async () => {
        try {
          const response = await this.executeRequest(url, options);

          // ğŸŒŸ æ·»åŠ æ—¥å¿—ï¼šæ£€æŸ¥å“åº”çŠ¶æ€ç å’Œç»“æœ
          if (response.responseCode !== 200) {
            // è®°å½•å¤±è´¥çš„è¯·æ±‚çš„è¯¦ç»†ä¿¡æ¯
            console.error(`[HTTP FAIL] URL: ${url}, Code: ${response.responseCode}, Result: ${response.result}`);
          } else {
            // è®°å½•æˆåŠŸçš„è¯·æ±‚ï¼ˆå¯ä»¥ç²¾ç®€ï¼‰
            console.info(`[HTTP OK] URL: ${url}, Code: ${response.responseCode}`);
          }

          resolve(response);
        } catch (error) {
          // ğŸŒŸ æ·»åŠ æ—¥å¿—ï¼šè®°å½•è¯·æ±‚æ‰§è¡Œæ—¶çš„å¼‚å¸¸ï¼ˆä¾‹å¦‚ç½‘ç»œé”™è¯¯ã€è¶…æ—¶ç­‰ï¼‰
          console.error(`[HTTP ERROR] URL: ${url}, Execution Error: ${JSON.stringify(error)}`);
          reject(error);
        }
      });
    });
  }

  private addToQueue(requestFn: () => void): void {
    this.requestQueue.push(requestFn);
    this.processQueue();
  }

  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.requestQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    while (this.requestQueue.length > 0) {
      // è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´
      const now = Date.now();
      const timeSinceLastRequest = now - this.lastRequestTime;
      const waitTime = Math.max(0, this.MIN_REQUEST_INTERVAL - timeSinceLastRequest);

      if (waitTime > 0) {
        await this.delay(waitTime);
      }

      // æ‰§è¡Œè¯·æ±‚
      const requestFn = this.requestQueue.shift();
      if (requestFn) {
        this.lastRequestTime = Date.now(); // æ›´æ–°æœ€åè¯·æ±‚æ—¶é—´
        requestFn(); // æ‰§è¡Œè¯·æ±‚ï¼ˆè¯·æ±‚æœ¬èº«ä¼šæ¶ˆè€—æ—¶é—´ï¼‰
      }
    }

    this.isProcessing = false;
  }

  private async executeRequest(url: string, options?: http.HttpRequestOptions): Promise<http.HttpResponse> {
    const httpRequest = http.createHttp();
    try {
      const response = await httpRequest.request(url, options);
      return response;
    } finally {
      httpRequest.destroy();
      console.info("ra_q_size = " + this.requestQueue.length)
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}