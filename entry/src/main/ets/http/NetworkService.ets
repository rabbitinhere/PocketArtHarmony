import { http } from '@kit.NetworkKit';

export class HttpHelper {
  private static instance: HttpHelper;
  private requestQueue: Array<() => void> = [];
  private isProcessing = false;
  private lastRequestTime = 0;

  // ä¿®æ­£ï¼šå°†å›ºå®šé—´éš”æ”¹ä¸ºéšæœºèŒƒå›´ï¼Œä»¥æ¨¡æ‹Ÿæ›´è‡ªç„¶çš„ç”¨æˆ·è¡Œä¸º
  private readonly MIN_DELAY = 20;
  private readonly MAX_DELAY = 50;

  private constructor() {
  }

  static getInstance(): HttpHelper {
    if (!HttpHelper.instance) {
      HttpHelper.instance = new HttpHelper();
    }
    return HttpHelper.instance;
  }

  async request(url: string, options?: http.HttpRequestOptions): Promise<http.HttpResponse> {
    return new Promise((resolve, reject) => {
      this.addToQueue(async () => {
        try {
          console.info(`[HTTP START] URL: ${url}`);
          const response = await this.executeRequest(url, options);

          // ğŸŒŸ æ·»åŠ æ—¥å¿—ï¼šæ£€æŸ¥å“åº”çŠ¶æ€ç å’Œç»“æœ
          if (response.responseCode !== 200) {
            // è®°å½•å¤±è´¥çš„è¯·æ±‚çš„è¯¦ç»†ä¿¡æ¯
            console.error(`[HTTP FAIL] URL: ${url}, Code: ${response.responseCode}, Result: ${response.result}`);
          } else {
            // è®°å½•æˆåŠŸçš„è¯·æ±‚ï¼ˆå¯ä»¥ç²¾ç®€ï¼‰
            console.info(`[HTTP OK] URL: ${url}, Code: ${response.responseCode}`);
          }

          resolve(response);
        } catch (error) {
          // ğŸŒŸ æ·»åŠ æ—¥å¿—ï¼šè®°å½•è¯·æ±‚æ‰§è¡Œæ—¶çš„å¼‚å¸¸ï¼ˆä¾‹å¦‚ç½‘ç»œé”™è¯¯ã€è¶…æ—¶ç­‰ï¼‰
          console.error(`[HTTP ERROR] URL: ${url}, Execution Error: ${JSON.stringify(error)}`);
          reject(error);
        }
      });
    });
  }

  private addToQueue(requestFn: () => void): void {
    this.requestQueue.push(requestFn);
    this.processQueue();
  }

  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.requestQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    while (this.requestQueue.length > 0) {

      // ğŸŒŸ æ ¸å¿ƒä¿®æ­£ï¼šè®¡ç®— 20ms åˆ° 50ms ä¹‹é—´çš„éšæœºé—´éš”
      // ç”Ÿæˆ [MIN_DELAY, MAX_DELAY] èŒƒå›´å†…çš„éšæœºæ•´æ•°
      const randomInterval = Math.floor(
        Math.random() * (this.MAX_DELAY - this.MIN_DELAY + 1)
      ) + this.MIN_DELAY;

      // è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´
      const now = Date.now();
      const timeSinceLastRequest = now - this.lastRequestTime;

      // ä½¿ç”¨éšæœºç”Ÿæˆçš„é—´éš”æ¥è®¡ç®—ç­‰å¾…æ—¶é—´
      const waitTime = Math.max(0, randomInterval - timeSinceLastRequest);

      console.info(`[HttpHelper] Required Interval: ${randomInterval}ms, Actual Wait Time: ${waitTime}ms`);

      if (waitTime > 0) {
        await this.delay(waitTime);
      }

      // æ‰§è¡Œè¯·æ±‚
      const requestFn = this.requestQueue.shift();
      if (requestFn) {
        this.lastRequestTime = Date.now(); // æ›´æ–°æœ€åè¯·æ±‚æ—¶é—´
        requestFn(); // æ‰§è¡Œè¯·æ±‚ï¼ˆè¯·æ±‚æœ¬èº«ä¼šæ¶ˆè€—æ—¶é—´ï¼‰
      }
    }

    this.isProcessing = false;
  }

  private async executeRequest(url: string, options?: http.HttpRequestOptions): Promise<http.HttpResponse> {
    const httpRequest = http.createHttp();
    try {
      const response = await httpRequest.request(url, options);
      return response;
    } finally {
      httpRequest.destroy();
      console.info("ra_q_size = " + this.requestQueue.length)
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}